#### 枚举类型与扩展

PostgreSQL 支持原生的枚举类型，比 MySQL 的字符串枚举更高效、安全。

```sql
-- 创建用户角色的枚举类型，规范用户身份
CREATE TYPE user_role_enum AS ENUM ('student', 'teacher', 'admin');
```

> 说明：定义了 `user_role_enum` 类型，后续在用户表中直接使用该类型，防止非法的角色字符串写入数据库。

-----

#### 1. 基础架构表

```sql
-- 1.1 学校表
CREATE TABLE sys_school (
    school_id SERIAL PRIMARY KEY, -- 使用 SERIAL 实现自增
    school_name VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE
);

-- 1.2 用户表
CREATE TABLE sys_user (
    user_id BIGSERIAL PRIMARY KEY, -- 大整数自增
    school_id INT NOT NULL REFERENCES sys_school(school_id), -- 外键约束
    username VARCHAR(100) NOT NULL UNIQUE, -- 唯一性约束
    password_hash VARCHAR(255) NOT NULL,
    role user_role_enum NOT NULL, -- 使用刚才定义的枚举
    real_name VARCHAR(100),
    student_teacher_no VARCHAR(50),
    college_major VARCHAR(100),
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 默认当前时间
    status SMALLINT DEFAULT 1 CHECK (status IN (0, 1)) -- 使用 Check 约束代替 Tinyint
);
```

> 说明：
>   * `SERIAL/BIGSERIAL`：PostgreSQL 中处理自增主键的标准方式。
>   * `REFERENCES`：直接在字段定义后声明外键，保证数据引用完整性。
>   * `CHECK (status IN (0, 1))`：PostgreSQL 没有 `TINYINT`，一般用 `SMALLINT` 配合 `CHECK` 约束来模拟布尔状态或小整数状态，确保数据合法。

-----

#### 2. 课程与教学教务表

```sql
-- 2.1 学期表
CREATE TABLE edu_semester (
    semester_id SERIAL PRIMARY KEY,
    semester_name VARCHAR(100) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL
);

-- 2.2 课程模板表
CREATE TABLE edu_course (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(200) NOT NULL,
    intro_content TEXT,
    task_requirements TEXT,
    is_public BOOLEAN DEFAULT FALSE
);

-- 2.3 教学班级表 (核心隔离表)
CREATE TABLE edu_class (
    class_id BIGSERIAL PRIMARY KEY,
    course_id INT NOT NULL REFERENCES edu_course(course_id),
    semester_id INT NOT NULL REFERENCES edu_semester(semester_id),
    teacher_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    class_name VARCHAR(100) NOT NULL,
    invite_code VARCHAR(50), -- 邀请码，可建立唯一索引
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_class_invite_code ON edu_class(invite_code);

-- 2.4 选课关联表
CREATE TABLE edu_enrollment (
    enrollment_id BIGSERIAL PRIMARY KEY,
    class_id BIGINT NOT NULL REFERENCES edu_class(class_id) ON DELETE CASCADE,
    student_id BIGINT NOT NULL REFERENCES sys_user(user_id) ON DELETE CASCADE,
    join_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (class_id, student_id) -- 防止重复选课
);
```

> 说明：
>   * `ON DELETE CASCADE`：在选课表中，如果班级或学生被删除，级联删除选课记录，防止脏数据。
>   * `UNIQUE (class_id, student_id)`：这是一个重要的完整性约束，物理上禁止了同一个学生重复加入同一个班级。

-----

#### 3. 任务一：Unity 仿真与测试表

```sql
-- 3.1 仿真学习记录
CREATE TABLE task_unity_record (
    record_id BIGSERIAL PRIMARY KEY,
    student_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    class_id BIGINT NOT NULL REFERENCES edu_class(class_id),
    learn_duration INT DEFAULT 0, -- 单位：秒
    completion_status BOOLEAN DEFAULT FALSE,
    last_access_time TIMESTAMP
);

-- 3.2 题库表
CREATE TABLE task_quiz_question (
    question_id BIGSERIAL PRIMARY KEY,
    course_id INT NOT NULL REFERENCES edu_course(course_id),
    question_text TEXT NOT NULL,
    options_json JSONB NOT NULL, -- PG 特性：使用 JSONB 存储选项
    correct_answer CHAR(1) CHECK (correct_answer IN ('A', 'B', 'C', 'D')),
    score_value INT DEFAULT 5
);

-- 3.3 测试成绩表
CREATE TABLE task_quiz_result (
    result_id BIGSERIAL PRIMARY KEY,
    student_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    class_id BIGINT NOT NULL REFERENCES edu_class(class_id),
    total_score INT CHECK (total_score BETWEEN 0 AND 100),
    is_passed BOOLEAN DEFAULT FALSE,
    attempt_count INT DEFAULT 1,
    submit_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

> 说明：
>   * `JSONB`：对于题目选项，这里使用了 PostgreSQL 强大的 `JSONB` 类型。相比 MySQL 的 `JSON` 或纯文本，`JSONB` 以二进制存储，支持索引，且解析速度更快。
>   * `CHECK` 约束：再次利用数据库层面的校验，保证分数在 0-100 之间，答案只能是 A/B/C/D。

-----

#### 4. 任务二与讨论区表

```sql
-- 4.1 家乡基地投稿
CREATE TABLE task_hometown_submission (
    submission_id BIGSERIAL PRIMARY KEY,
    student_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    class_id BIGINT NOT NULL REFERENCES edu_class(class_id),
    base_name VARCHAR(200) NOT NULL,
    location VARCHAR(200),
    description TEXT,
    attachment_url VARCHAR(500),
    submit_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    teacher_feedback TEXT
);

-- 4.2 讨论区帖子
CREATE TABLE forum_topic (
    topic_id BIGSERIAL PRIMARY KEY,
    class_id BIGINT NOT NULL REFERENCES edu_class(class_id),
    user_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    title VARCHAR(200) NOT NULL,
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 4.3 讨论区评论
CREATE TABLE forum_comment (
    comment_id BIGSERIAL PRIMARY KEY,
    topic_id BIGINT NOT NULL REFERENCES forum_topic(topic_id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES sys_user(user_id),
    content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

> 说明：这里基本沿用了标准设计，为 `forum_comment` 的 `topic_id` 增加了级联删除，如果主贴被删，评论自动清除。

-----

#### 5. 视图 (View)：教师端任务概览

```sql
CREATE OR REPLACE VIEW view_teacher_task1_summary AS
SELECT 
    e.class_id,
    u.student_teacher_no,
    u.real_name,
    COALESCE(tqr.total_score, 0) as total_score, -- 空值处理为0
    COALESCE(tqr.is_passed, FALSE) as is_passed,
    COALESCE(tur.learn_duration, 0) as learn_duration,
    COALESCE(tur.completion_status, FALSE) AS sim_completed
FROM 
    edu_enrollment e
JOIN 
    sys_user u ON e.student_id = u.user_id
LEFT JOIN 
    task_quiz_result tqr ON e.student_id = tqr.student_id AND e.class_id = tqr.class_id
LEFT JOIN 
    task_unity_record tur ON e.student_id = tur.student_id AND e.class_id = tur.class_id;
```

> 说明：使用了 `COALESCE` 函数处理 `NULL` 值，确保前端展示时不会出现空白，而是显示 0 或 False。该视图通过 `Left Join` 保证了即使学生未开始任务，老师也能在列表中看到该学生（显示为 0 分）。

-----

#### 6. 逻辑实现：触发器 (Trigger)

PostgreSQL 的触发器机制与 MySQL 不同，需要先定义一个 Function，再创建 Trigger 绑定该函数。

```sql
-- 第一步：定义触发器函数
CREATE OR REPLACE FUNCTION func_check_quiz_pass()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.total_score >= 70 THEN
        NEW.is_passed := TRUE;
    ELSE
        NEW.is_passed := FALSE;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 第二步：绑定触发器
CREATE TRIGGER trg_check_quiz_pass
BEFORE INSERT OR UPDATE ON task_quiz_result -- 增加 UPDATE 监控
FOR EACH ROW
EXECUTE FUNCTION func_check_quiz_pass();
```

> 说明：
>   * 使用 `PL/pgSQL` 语言编写。
>   * 增加了 `OR UPDATE`，防止后续修改分数时 `is_passed` 状态没有同步更新。

-----

#### 7. 逻辑实现：存储过程 (Function) - 开课

PostgreSQL 中通常使用函数（Function）来实现存储过程的逻辑。

```sql
CREATE OR REPLACE FUNCTION sp_create_class_instance(
    p_teacher_id BIGINT,
    p_course_id INT,
    p_semester_id INT,
    p_class_name VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_invite_code VARCHAR(20);
BEGIN
    -- 生成 8 位邀请码，使用 md5 截取并大写
    v_invite_code := UPPER(SUBSTRING(MD5(p_teacher_id::TEXT || p_course_id::TEXT || p_semester_id::TEXT || NOW()::TEXT || p_class_name), 1, 8));
    
    INSERT INTO edu_class (
        course_id, 
        semester_id, 
        teacher_id, 
        class_name, 
        invite_code
    )
    VALUES (
        p_course_id, 
        p_semester_id, 
        p_teacher_id, 
        p_class_name, 
        v_invite_code
    );
    
    -- 返回生成的邀请码
    RETURN v_invite_code;
END;
$$ LANGUAGE plpgsql;
```

> 说明：
>   * `||` 是 PostgreSQL 的字符串拼接符（MySQL 是 `CONCAT`）。
>   * `::TEXT` 用于强制类型转换，确保拼接顺利。
>   * 函数直接返回生成的邀请码，方便后端 API 直接响应给前端。

-----

### 第二部分：安全性、完整性与性能提升的 5 点考量

在设计思政实践平台数据库时，除了基本的 CRUD，还需要考虑以下关键点：

#### 1. 安全性：行级安全策略

由于需求中明确提到“每门思政课之间不会干扰”、“允许外校使用”，这意味着这是一个多租户（Multi-tenant）系统。仅仅依靠后端代码（Where 子句）来隔离数据风险很大。

- 措施：启用 PostgreSQL 的 RLS 功能。
- 实现：
    ```sql
    ALTER TABLE edu_class ENABLE ROW LEVEL SECURITY;
    -- 创建策略：用户只能看到自己学校的课程，或者自己班级的内容
    CREATE POLICY school_isolation_policy ON edu_class
    USING (teacher_id = current_user_id() OR class_id IN (SELECT class_id FROM edu_enrollment WHERE student_id = current_user_id()));
    ```
- 收益：即使后端 SQL 注入或逻辑遗漏，物理层面上用户也无法查询到其他学校或其他班级的数据。

#### 2. 性能：JSONB 索引优化题库查询

`task_quiz_question` 表使用了 `options_json`。如果不加处理，查询特定选项或解析 JSON 会很慢。

- 措施：使用 `JSONB` 并建立 GIN 索引。
- 实现：
    ```sql
    CREATE INDEX idx_quiz_options ON task_quiz_question USING GIN (options_json);
    ```
- 收益：极大提升 JSON 数据的读取和解析效率，特别是当题库量变大，或者需要搜索特定选项内容时。

#### 3. 完整性：密码存储与加密

原设计中 `password_hash` 仅为 VARCHAR。在 PostgreSQL 中，不建议自己在应用层做简单的 MD5。

- 措施：使用 PostgreSQL 的 `pgcrypto` 扩展生成加盐哈希（如 bcrypt）。
- 实现：
    ```sql
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
    -- 插入时使用：
    -- crypt('用户密码', gen_salt('bf'))
    ```
- 收益：相比普通 MD5，Bcrypt 能够有效防御彩虹表攻击，保障高校用户信息安全（尤其是学生学号和真实姓名等隐私）。

#### 4. 性能：外键索引的手动建立

在 PostgreSQL 中，外键字段不会自动创建索引。

- 措施：为所有用于连接（JOIN）或过滤的外键字段显式创建索引。
- 关注点：特别是 `edu_enrollment(student_id)` 和 `task_quiz_result(class_id)`。因为教师端需要频繁通过班级 ID 聚合查询所有学生的成绩。
- 收益：避免在查询班级成绩单时发生全表扫描，显著提升教师端“任务一完成情况”页面的加载速度。

#### 5. 完整性：防重复提交与并发控制

在“任务一”的测试中，如果学生网络卡顿多次点击提交，可能会产生多条成绩记录。

- 措施：在应用层逻辑之外，增加数据库唯一性约束或部分索引。
- 思路：虽然允许 `attempt_count` 多次尝试，但如果是“单次考试会话”，应限制同一时间点的重复写入。或者，如果业务逻辑改为“每人每课只有一条最终成绩记录（覆盖更新）”，则应在 `(student_id, class_id)` 上建立唯一索引。
- 收益：保证数据的绝对准确性，防止因前端 Bug 导致的分数统计错误。